import robby
#import numpy as np
from utils import *
import random
POSSIBLE_ACTIONS = ["MoveNorth", "MoveSouth", "MoveEast", "MoveWest", "StayPut", "PickUpCan", "MoveRandom"]
rw = robby.World(10, 10)
rw.graphicsOff()


def sortByFitness(genomes):
    tuples = [(fitness(g), g) for g in genomes]
    tuples.sort()
    sortedFitnessValues = [f for (f, g) in tuples]
    sortedGenomes = [g for (f, g) in tuples]
    return sortedGenomes, sortedFitnessValues

def eval_and_sort(population):
    scored = [(fitness(g), g) for g in population]
    avg = sum(s for s, _ in scored) / len(scored)
    scored.sort()  # ascending by fitness
    best_fit, best_genome = scored[-1]
    sortedGenomes = [g for _, g in scored]
    sortedFitness = [s for s, _ in scored]
    return avg, best_fit, best_genome, sortedGenomes, sortedFitness


def randomGenome(length):
    """
    :param length:
    :return: string, random integers between 0 and 6 inclusive
    """
    result = ""
    for i in range(0, length):
        result += str(random.randint(0,6))
    return result


def makePopulation(size, length):
    """
    :param size - of population:
    :param length - of genome
    :return: list of length size containing genomes of length length
    """
    population = []
    for i in range(size):
        population.append(randomGenome(length))
    return(population)

def fitness(genome, steps=200, init=0.50):
    """

    :param genome: to test
    :param steps: number of steps in the cleaning session
    :param init: amount of cans
    :return:
    """
    if type(genome) is not str or len(genome) != 243:
        raise Exception("strategy is not a string of length 243")
    for char in genome:
        if char not in "0123456":
            raise Exception("strategy contains a bad character: '%s'" % char)
    if type(steps) is not int or steps < 1:
        raise Exception("steps must be an integer > 0")

    rewards = [0 for _ in range(25)]
    rw.graphicsOff()
    
    for run in range(25):
        # Reset my board state for each run
        if type(init) is str:
        # init is a config file
            rw.load(init)
        elif type(init) in [int, float] and 0 <= init <= 1:
            # init is a can density
            rw.distributeCans(init)
            
        x = random.randrange(rw.numRows)
        y = random.randrange(rw.numCols)
        rw.goto(x, y) 
        
        # Run my steps
        for i in range(steps):
            p = rw.getPerceptCode()
            action = POSSIBLE_ACTIONS[int(genome[p])]
            rewards[run] += rw.performAction(action)
           
    # Average and return my results
    avg = sum(rewards) / len(rewards)
    return(avg)
            

def evaluateFitness(population):
    """
    :param population:
    :return: a pair of values: the average fitness of the population as a whole and the fitness of the best individual
    in the population.
    """
    fitnesses = [0 for _ in range(len(population))]
    for i in range(len(population)):
        fitnesses[i] = fitness(population[i])
    return((sum(fitnesses) / len(fitnesses)), max(fitnesses))



def crossover(genome1, genome2):
    """
    :param genome1:
    :param genome2:
    :return: two new genomes produced by crossing over the given genomes at a random crossover point.
    """
    crossPoint = random.randrange(1, len(genome1))
    child1 = genome1[:crossPoint] + genome2[crossPoint:]
    child2 = genome2[:crossPoint] + genome1[crossPoint:]
    
    return(child1, child2)


def mutate(genome, mutationRate):
    """
    :param genome:
    :param mutationRate:
    :return: a new mutated version of the given genome.
    """
    new_genome = ""
    for step in genome:
        if random.random() < mutationRate:
            new_genome += str(random.randint(0,6))
        else:
            new_genome += step
    return(new_genome)

def selectPair(population):
    """

    :param population:
    :return: two genomes from the given population using fitness-proportionate selection.
    This function should use RankSelection,
    """
    sortedGenomes, sortedFitness = sortByFitness(population)
    n = len(sortedGenomes)
    
    weights = list(range(1, n+1))
    
    result1 = weightedChoice(sortedGenomes, weights)
    result2 = weightedChoice(sortedGenomes, weights)
    
    return(result1,result2)


def runGA(populationSize, crossoverRate, mutationRate, logFile=""):
    """

    :param populationSize: :param crossoverRate: :param mutationRate: :param logFile: :return: xt file in which to
    store the data generated by the GA, for plotting purposes. When the GA terminates, this function should return
    the generation at which the string of all ones was found.is the main GA program, which takes the population size,
    crossover rate (pc), and mutation rate (pm) as parameters. The optional logFile parameter is a string specifying
    the name of a te
    """
    genome_length = 243
    max_generations = 300
    
    print(f'Population size: {populationSize}')
    print(f'Genome length: {genome_length}')
    
    population = makePopulation(populationSize, genome_length)
    generations_log = []

    best_so_far_fit = float("-inf")
    best_so_far_strat = None
    best_so_far_gen = None
    
    for gen in range(max_generations):
        avg, best_fit, best_genome, sortedGenomes, sortedFitness = eval_and_sort(population)
        print(f'Generation {gen}: average fitness {avg}, best fitness {best_fit}')
        
        if logFile and (gen % 10 == 0):
            with open(logFile, "a") as f:
                f.write(f"{best_so_far_gen},{best_so_far_fit},{best_so_far_strat}\n")
        
        generations_log.append((gen, avg, best_fit, best_genome))
        
        if best_fit > best_so_far_fit:
            best_so_far_fit = best_fit
            best_so_far_strat = best_genome
            best_so_far_gen = gen
            
        if (gen % 20 == 0) and best_so_far_strat:
            rw.demo(best_so_far_strat)

        new_population = []
        while len(new_population) < populationSize:
            # select my pair to crossover
            p1, p2 = selectPair(population)
            
            if random.random() < crossoverRate:
                c1, c2 = crossover(p1, p2)
            else:
                c1, c2 = p1, p2
            
            c1 = mutate(c1, mutationRate)
            c2 = mutate(c2, mutationRate)
            
            new_population.append(c1)
            if len(new_population) < populationSize:
                new_population.append(c2)
                
        population = new_population
        
    return(best_so_far_strat)    


def test_FitnessFunction():
    f = fitness(rw.strategyM)
    print("Fitness for StrategyM : {0}".format(f))



# test_FitnessFunction()

with open ("bestStrategy.csv", "w") as f:
    f.write('Generation, Best Fitness, Best Genome\n')
runGA(50, 1.0, 0.001,"bestStrategy.csv")